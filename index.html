<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dino Runner 2D - 16 Bit Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #101010;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-wrapper {
            position: relative;
            /* 16:9 aspect ratio container */
            width: 90vw;
            max-width: 960px;
            aspect-ratio: 4/3;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 4px solid #444;
            border-radius: 4px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* Critical for pixel art: keep edges sharp when scaling up */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* CRT Scanline Overlay */
        /* CRT Scanline Overlay - Intense Dystopian */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom,
                    rgba(18, 16, 16, 0),
                    rgba(18, 16, 16, 0) 50%,
                    rgba(0, 0, 0, 0.4) 50%,
                    rgba(0, 0, 0, 0.4));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* Vignette for old TV feel */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.85);
            pointer-events: none;
            z-index: 11;
            border-radius: 4px;
            background: radial-gradient(circle, rgba(100, 0, 100, 0.1) 0%, rgba(0, 0, 0, 0.4) 100%);
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #0ff;
            text-shadow: 2px 2px #000, 0 0 10px #0ff;
            font-size: 16px;
            /* Scaled relative to canvas */
            z-index: 20;
            text-align: right;
        }

        #start-screen,
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #0ff;
            text-shadow: 2px 2px 0 #000, 0 0 8px #f0f;
            background: rgba(20, 0, 40, 0.9);
            padding: 24px;
            border: 4px solid #f0f;
            box-shadow: 0 0 20px #f0f;
            z-index: 30;
            min-width: 280px;
        }

        h1 {
            font-size: 24px;
            color: #f0f;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            text-shadow: 3px 3px 0 #000;
        }

        p {
            font-size: 12px;
            line-height: 1.8;
            color: #fff;
            margin: 10px 0;
        }

        .blink {
            animation: blinker 0.8s steps(2, start) infinite;
            color: #0ff;
            cursor: pointer;
            margin-top: 20px;
            text-shadow: 0 0 5px #0ff;
        }

        @keyframes blinker {
            to {
                visibility: hidden;
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <div id="game-wrapper">
        <div class="scanlines"></div>
        <div class="vignette"></div>

        <div id="ui-layer">
            <span id="score-display">00000</span>
            <span style="font-size: 10px; color: #f0f; display: block; margin-top:5px;">HI <span
                    id="high-score-display">00000</span></span>
            <div id="effects-display"
                style="margin-top: 10px; font-size: 10px; color: #ffff00; text-shadow: 0 0 5px red;"></div>
        </div>

        <div id="start-screen">
            <h1>DINO RUN</h1>
            <p>DYSTOPIAN EDITION</p>
            <p style="color: #aaa; font-size: 10px;">SPACE / UP - JUMP</p>
            <p style="color: #aaa; font-size: 10px;">F - SHOOT | 1-4 - SKINS | C - CHEAT</p>
            <p style="color: #888; font-size: 8px; margin-top: 10px;">MOBILE: TAP LEFT-SHOOT | RIGHT-JUMP</p>
            <p class="blink" id="start-btn">INSERT CREDITS</p>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1 class="blink">GAME OVER</h1>
            <p id="final-score">SCORE: 0</p>
            <p class="blink">PRESS SPACE TO RESTART</p>
            <p style="margin-top: 20px; font-size: 10px; color: rgba(255,255,255,0.5);">DEVELOPED BY ORION</p>
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        /**
         * SPRITE DEFINITIONS (Binary Art)
         * 1 = Drawn pixel, 0 = Transparent
         * Designed for a 16-bit feel
         */
        const Sprites = {
            dinoRun1: [
                "000000111100",
                "000001111111",
                "000001111110",
                "000001111100",
                "000001111100",
                "000001111100",
                "100011111100",
                "100111111100",
                "111111111100",
                "111111111100",
                "011111111000",
                "001111110000",
                "001100110000",
                "001000100000"
            ],
            dinoRun2: [
                "000000111100",
                "000001111111",
                "000001111110",
                "000001111100",
                "000001111100",
                "000001111100",
                "100011111100",
                "100111111100",
                "111111111100",
                "111111111100",
                "011111111000",
                "001111110000",
                "000100000000",
                "000110000000"
            ],
            dinoDuck1: [
                "000000000000",
                "000000000000",
                "000000000000",
                "000000000000",
                "000000111100",
                "000001111111",
                "000001111110",
                "100011111100",
                "100111111100",
                "111111111100",
                "111111111100",
                "011111111000",
                "001100110000",
                "001000100000"
            ],
            dinoDuck2: [
                "000000000000",
                "000000000000",
                "000000000000",
                "000000000000",
                "000000111100",
                "000001111111",
                "000001111110",
                "100011111100",
                "100111111100",
                "111111111100",
                "111111111100",
                "011111111000",
                "001111110000",
                "000100000000",
                "000110000000"
            ],
            boss: [
                "0011111100",
                "0111111110",
                "1110000111",
                "1100110011",
                "1100110011",
                "1110000111",
                "1111111111",
                "0110000110",
                "0011111100",
                "0001111000"
            ],
            bossProj: [
                "101",
                "010",
                "101"
            ],
            cactusSmall: [
                "00011000",
                "00111000",
                "01111100",
                "11111100",
                "11111100",
                "01111110",
                "00111110",
                "00111100",
                "00111100",
                "00111100"
            ],
            cactusBig: [
                "000110000",
                "000110000",
                "001111000",
                "011111000",
                "111111001",
                "111111011",
                "011111111",
                "001111110",
                "001111000",
                "001111000",
                "001111000",
                "001111000"
            ],
            bird1: [
                "00000011",
                "00001110",
                "00111100",
                "11111000",
                "00110000"
            ],
            bird2: [
                "00000011",
                "00001110",
                "00111100",
                "00000000",
                "00111000"
            ],
            gem: [
                "0001000",
                "0011100",
                "0111110",
                "1111111",
                "0111110",
                "0011100",
                "0001000"
            ],
            shield: [
                "0011100",
                "0111110",
                "1100011",
                "1100011",
                "1100011",
                "0111110",
                "0011100"
            ],
            double: [
                "0011110",
                "0100001",
                "0001110",
                "0011000",
                "0111111",
                "0000000"
            ],
            projectile: [
                "1111",
                "1111",
                "1111",
                "1111"
            ]
        };

        /**
         * CONFIGURATION
         * Retro Console Resolution: 320x224 (Genesis/Mega Drive)
         */
        const CANVAS_WIDTH = 320;
        const CANVAS_HEIGHT = 224;
        const GROUND_Y = 190;

        const COLORS = {
            sky: "#2b102f",        // Dark Purple Dystopian Sky
            ground: "#111111",     // Dark Asphalt
            groundDark: "#ff00ff", // Neon Magenta Grid Highlights
            cactus: "#00ff00",     // Matrix Green Glitch Spikes
            bird: "#ff0055",       // Neon Red Enemy
            cloud: "#443355",      // Dark Smog
            gem: "#00ffff",        // Cyan Neon
            shield: "#0088ff",     // Electric Blue
            double: "#ff00ff",     // Magenta
            projectile: "#ffff00"  // Bright Yellow Laser
        };

        const SKINS = [
            "#00ff00", // Matrix Green
            "#00ffff", // Cyber Cyan
            "#ff00ff", // Neon Pink
            "#ffffff"  // Pure White
        ];

        /**
         * AUDIO SYSTEM (Web Audio API)
         */
        const AudioSys = {
            ctx: null,
            init: function () {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone: function (freq, type, duration, volStart = 0.1, volEnd = 0.01) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(volStart, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(volEnd, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            jump: function () { this.playTone(150, 'square', 0.1, 0.1, 0.01); },
            die: function () {
                if (!this.ctx) return;
                this.playTone(300, 'sawtooth', 0.5, 0.2, 0.001);
            },
            score: function () {
                if (!this.ctx) return;
                this.playTone(600, 'sine', 0.1);
                setTimeout(() => this.playTone(900, 'sine', 0.2), 100);
            },
            shoot: function () { this.playTone(400, 'square', 0.05, 0.1, 0.001); },
            collect: function () { this.playTone(800, 'sine', 0.15, 0.1, 0.01); },
            powerup: function () {
                if (!this.ctx) return;
                this.playTone(400, 'triangle', 0.1);
                setTimeout(() => this.playTone(600, 'triangle', 0.1), 100);
                setTimeout(() => this.playTone(800, 'triangle', 0.2), 200);
            }
        };

        /**
         * GAME ENGINE
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set internal resolution low for pixel look
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Game State
        let gameLoop;
        let frames = 0;
        let score = 0;
        let highScore = 0;
        let speed = 2.5;
        let isPlaying = false;
        let particles = [];
        let groundOffset = 0;

        // Entities
        // Global Game State
        let isPaused = false;
        let screenShake = 0;

        // Boss State
        let isBossActive = false;
        let boss = { x: 0, y: 0, w: 40, h: 40, hp: 0, maxHp: 10, dy: 1 };
        let bossProjectiles = [];
        let timeSinceLastBoss = 0;
        let bossKillCount = 0;

        // Entities
        let obstacles = [];
        let clouds = [];
        let projectiles = [];
        let gems = [];
        let powerups = [];

        // Cheats / Effects
        let cheatMode = false;
        let comboCount = 0;

        // Load Storage
        try {
            const savedScore = localStorage.getItem('dinoHighScore');
            if (savedScore) highScore = parseInt(savedScore);
            // document reference might not be ready if script runs too early? 
            // Script is at end of body, so it's fine.
            // But Element might be updated in resetGame too.
        } catch (e) { }

        // Player Object
        const dino = {
            x: 30,
            y: GROUND_Y,
            w: 24, // width scaled (sprite is 12px wide * 2 scale)
            h: 28, // height scaled
            dy: 0,
            jumpPower: -5.5,
            gravity: 0.25,
            grounded: true,
            scale: 2, // Pixel scale factor

            // New Features
            skinIdx: 0,
            shieldTime: 0,
            doubleScoreTime: 0,
            isDucking: false,

            draw: function () {
                // Animation logic
                let sprite;
                if (this.isDucking) {
                    sprite = (Math.floor(frames / 8) % 2 === 0) ? Sprites.dinoDuck1 : Sprites.dinoDuck2;
                    this.h = 20; // Reduce height visually (logic handled elsewhere too)
                } else {
                    this.h = 28;
                    sprite = (Math.floor(frames / 8) % 2 === 0 || !this.grounded)
                        ? Sprites.dinoRun1
                        : Sprites.dinoRun2;
                }

                const color = cheatMode ? "#ffff00" : SKINS[this.skinIdx];
                // Always draw from base Y - 28 to keep alignment even when ducking
                // Duck sprite is padded? No, defined at top. 
                // We should rely on this.y being ground.
                // If ducking, h is 20. y - h = y - 20.
                // But normal is y - 28.
                // We want the feet at the same place.
                // If sprite is top-aligned in 16x16 box, we need to adjust.
                // Let's simplified: Draw at y - 28 always for sprite alignment, but collision box changes.

                // Be careful: drawSprite draws at x, y. 
                // If we pass y - 28, it draws from top.
                // Start drawing at y - 28 ensures feet are at y (since sprite is ~14px * 2 = 28).
                drawSprite(ctx, sprite, this.x, this.y - 28, this.scale, color);

                // Draw Shield Bubble
                if (this.shieldTime > 0) {
                    ctx.strokeStyle = "#4488ff";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x + 12, this.y - 14, 18, 0, Math.PI * 2);
                    ctx.stroke();
                    if (this.shieldTime < 60 && Math.floor(frames / 5) % 2 === 0) {
                        ctx.strokeStyle = "rgba(0,0,0,0)";
                    }
                }
            },

            update: function () {
                if (this.shieldTime > 0) this.shieldTime--;
                if (this.doubleScoreTime > 0) this.doubleScoreTime--;

                // Physics
                this.y += this.dy;

                if (this.y < GROUND_Y) {
                    this.dy += this.gravity;
                    this.grounded = false;
                } else {
                    if (!this.grounded) {
                        // Just landed
                        if (comboCount > 0) {
                            // Maybe sound effect for ending combo?
                            comboCount = 0;
                        }
                    }
                    this.y = GROUND_Y;
                    this.dy = 0;
                    this.grounded = true;
                }
            },

            jump: function () {
                if (this.grounded && !this.isDucking) {
                    this.dy = this.jumpPower;
                    this.grounded = false;
                    AudioSys.jump();
                    spawnDust(this.x + 10, this.y);
                    if (navigator.vibrate) navigator.vibrate(20);
                }
            },

            shoot: function () {
                if (projectiles.length < 3) {
                    AudioSys.shoot();
                    projectiles.push({
                        x: this.x + 20,
                        y: this.y - (this.isDucking ? 10 : 16),
                        w: 8, h: 8,
                        dx: 6
                    });
                    if (navigator.vibrate) navigator.vibrate(10);
                    screenShake = 2;
                }
            }
        };

        function spawnDust(x, y) {
            for (let i = 0; i < 12; i++) {
                let angle = (Math.PI * 2 / 12) * i;
                let speed = Math.random() * 2 + 1;
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 15,
                    color: Math.random() > 0.5 ? '#ffff00' : '#ff5500' // Fire colors
                });
            }
        }

        /**
         * HELPER: Draw Binary Sprite
         */
        function drawSprite(context, spriteMap, x, y, scale, color) {
            context.fillStyle = color;
            for (let r = 0; r < spriteMap.length; r++) {
                const row = spriteMap[r];
                for (let c = 0; c < row.length; c++) {
                    if (row[c] === '1') {
                        context.fillRect(x + c * scale, y + r * scale, scale, scale);
                    }
                }
            }
        }

        /**
         * MANAGERS
         */
        function spawnObstacle() {
            const type = Math.random() > 0.7 ? 'bird' : 'cactus';
            let obstacle = {
                x: CANVAS_WIDTH + 20,
                y: GROUND_Y,
                type: type,
                scale: type === 'bird' ? 2.2 : 2, // Birds slightly bigger
                dead: false,
                isGlitch: (Math.random() > 0.8 && type === 'bird') // 20% chance for glitch bird
            };

            if (type === 'cactus') {
                obstacle.sprite = Math.random() > 0.5 ? Sprites.cactusBig : Sprites.cactusSmall;
                obstacle.y = GROUND_Y;
                obstacle.w = obstacle.sprite[0].length * 2;
                obstacle.h = obstacle.sprite.length * 2;
            } else {
                obstacle.sprite = Sprites.bird1;
                const heights = [30, 50, 10]; // offset from ground
                obstacle.y = GROUND_Y - heights[Math.floor(Math.random() * heights.length)];
                obstacle.w = obstacle.sprite[0].length * 2;
                obstacle.h = obstacle.sprite.length * 2;
            }

            obstacles.push(obstacle);
        }

        function spawnCloud() {
            clouds.push({
                x: CANVAS_WIDTH + 50,
                y: Math.random() * 100 + 20,
                w: 40,
                h: 12,
                speed: Math.random() * 0.5 + 0.2
            });
        }

        function spawnGem() {
            gems.push({
                x: CANVAS_WIDTH + 20,
                y: GROUND_Y - 40,
                w: 14, h: 14,
                value: 100
            });
        }

        function spawnPowerup() {
            const type = Math.random() > 0.5 ? 'shield' : 'double';
            powerups.push({
                x: CANVAS_WIDTH + 20,
                y: GROUND_Y - 30, // floating
                w: 14, h: 14,
                type: type
            });
        }

        function resetGame() {
            dino.y = GROUND_Y;
            dino.dy = 0;
            dino.shieldTime = 0;
            dino.doubleScoreTime = 0;
            comboCount = 0;

            obstacles = [];
            clouds = [];
            particles = [];
            projectiles = [];
            gems = [];
            powerups = [];

            score = 0;
            frames = 0;
            speed = 2.5;
            isPlaying = true;

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');

            AudioSys.init();
            spawnCloud();
            screenShake = 0;

            // Start loop
            if (gameLoop) cancelAnimationFrame(gameLoop);
            loop();
        }

        function checkCollision(rect1, rect2) {
            const margin = 4;
            // rect1/rect2 coords are mixed bottom/top-left logic in this codebase.
            // We'll normalize to Check AABB assuming (x,y) is top-left of the bounding box
            // For Dino: x=x, y=y-h (since y is ground)
            // For Obstacle: x=x, y=y-h (since y is ground)

            let r1x = rect1.x;
            let r1y = rect1.y - rect1.h; // Top
            let r1w = rect1.w;
            let r1h = rect1.h;

            let r2x = rect2.x;
            let r2y = rect2.y - rect2.h; // Top, if y is bottom
            let r2w = rect2.w;
            let r2h = rect2.h;

            if (rect2.isTopLeft) { // Special flag if we want
                r2y = rect2.y; // Already top-left
            }

            return (
                r1x < r2x + r2w - margin &&
                r1x + r1w - margin > r2x &&
                r1y < r2y + r2h - margin &&
                r1y + r1h - margin > r2y
            );
        }

        /**
         * MAIN LOOP
         */
        function loop() {
            if (!isPlaying || isPaused) {
                if (isPaused) requestAnimationFrame(loop); // Keep requesting to catch unpause
                return;
            }

            gameLoop = requestAnimationFrame(loop);
            frames++;

            // 1. UPDATE
            dino.update();

            // Difficulty scaling
            let currentSpeed = speed;
            if (cheatMode) currentSpeed *= 1.5;

            if (frames % 600 === 0) {
                speed += 0.2;
                AudioSys.score();
            }

            // Spawn Spawn
            // Spawn Logic (Only if Boss inactive)
            if (!isBossActive) {
                // Check Boss Spawn
                if (score > 2000 && score % 2000 < 100 && timeSinceLastBoss > 3000) {
                    // Spawn Boss
                    isBossActive = true;
                    boss.hp = boss.maxHp;
                    boss.x = CANVAS_WIDTH - 60;
                    boss.y = 50;
                    boss.dy = 1;
                    timeSinceLastBoss = 0;
                    // Clear obstacles for fair fight
                    obstacles = [];

                    // Boss Warning
                    let warning = document.createElement('div');
                    warning.style.position = 'absolute';
                    warning.style.top = '50%';
                    warning.style.left = '50%';
                    warning.style.transform = 'translate(-50%, -50%)';
                    warning.style.color = '#ff0000';
                    warning.style.fontFamily = "'Press Start 2P', monospace";
                    warning.style.fontSize = '30px';
                    warning.style.textShadow = '0 0 10px #ff0000';
                    warning.innerText = "WARNING: GLITCH CORE";
                    document.body.appendChild(warning);
                    setTimeout(() => warning.remove(), 2000);
                } else {
                    const lastOb = obstacles[obstacles.length - 1];
                    if (!lastOb || (CANVAS_WIDTH - lastOb.x > (Math.random() * 100 + 80 * (speed / 2)))) {
                        let roll = Math.random();
                        if (roll < 0.02) spawnObstacle();
                        else if (roll < 0.023) spawnGem();
                        else if (roll < 0.025) spawnPowerup();
                    }
                }
            } else {
                // Update Boss
                boss.y += boss.dy;
                if (boss.y < 20 || boss.y > 100) boss.dy *= -1;

                // Boss Shoot
                if (Math.random() < 0.02) {
                    bossProjectiles.push({
                        x: boss.x,
                        y: boss.y + 20,
                        dx: -4,
                        w: 12, h: 4
                    });
                    AudioSys.shoot();
                }

                // Boss Collision (Player Proj vs Boss)
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    let p = projectiles[i];
                    if (p.x + p.w > boss.x && p.x < boss.x + boss.w && p.y + p.h > boss.y && p.y < boss.y + boss.h) {
                        boss.hp--;
                        projectiles.splice(i, 1);
                        screenShake = 5;
                        AudioSys.jump(); // Hit sound
                        // Boss Dead?
                        if (boss.hp <= 0) {
                            isBossActive = false;

                            // Exponential Reward
                            let reward = 1000 * Math.pow(2, bossKillCount);
                            bossKillCount++;
                            score += reward;

                            timeSinceLastBoss = 0;
                            screenShake = 20;
                            spawnDust(boss.x + 20, boss.y + 20); // Big Boom

                            // Grand Text
                            particles.push({
                                x: boss.x - 20, y: boss.y,
                                dx: 0, dy: -0.5,
                                life: 120, // 2 seconds
                                text: "+" + reward + "!!!",
                                color: "#ffd700", // Gold
                                isGrand: true
                            });
                        }
                    }
                }
            }

            if (!isBossActive) timeSinceLastBoss++;

            // Spawn clouds
            if (Math.random() < 0.01) spawnCloud();

            // Update Score
            // Update Score
            // Constant update
            let points = 1;
            if (dino.doubleScoreTime > 0) points *= 2;
            score += points;
            document.getElementById('score-display').innerText = score.toString().padStart(5, '0');

            // Update UI Effects
            let effectsText = "";
            if (cheatMode) effectsText += "CHEAT ";
            if (dino.shieldTime > 0) effectsText += "SHIELD ";
            if (dino.doubleScoreTime > 0) effectsText += "2X ";
            if (comboCount > 1) effectsText += "COMBO x" + comboCount + " ";
            document.getElementById('effects-display').innerText = effectsText;


            // 2. DRAW

            // Draw Sky (Dynamic)
            let skyColor = COLORS.sky;
            if (score > 3000) skyColor = "#2f1010"; // Red (Boss Zone)
            if (score > 6000) skyColor = "#000022"; // Deep Space

            ctx.fillStyle = skyColor;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Screen Shake Apply
            ctx.save();
            if (screenShake > 0) {
                let mag = screenShake;
                let dx = (Math.random() - 0.5) * mag;
                let dy = (Math.random() - 0.5) * mag;
                ctx.translate(dx, dy);
                screenShake *= 0.9; // Decay
                if (screenShake < 0.5) screenShake = 0;
            }

            // Draw Parallax City
            // Simple procedural city silhouette
            // Draw Parallax City (Fixed)
            ctx.fillStyle = "#1a0b1c";
            const parallaxScroll = groundOffset * 0.2;
            const blockWidth = 24;
            // Determine which "blocks" of the city are visible
            const startBlock = Math.floor(parallaxScroll / blockWidth);
            const visibleBlocks = Math.ceil(CANVAS_WIDTH / blockWidth) + 1;

            for (let i = startBlock; i < startBlock + visibleBlocks; i++) {
                // Procedural generation based on Block Index 'i' (stable)
                // Use a pseudo-random determinstic height based on i
                let h = 20 + Math.abs(Math.sin(i * 132.1)) * 50;
                if (i % 5 === 0) h += 60; // Skyscraper every 5th block
                if (i % 3 === 0) h += 20;

                let drawX = (i * blockWidth) - parallaxScroll;

                ctx.fillRect(drawX, GROUND_Y - h, blockWidth + 1, h); // +1 overlap

                // Windows
                ctx.fillStyle = "#331133";
                if (i % 5 === 0) { // Skyscraper windows
                    for (let wy = GROUND_Y - h + 10; wy < GROUND_Y - 10; wy += 10) {
                        ctx.fillRect(drawX + 4, wy, 4, 6);
                        ctx.fillRect(drawX + 14, wy, 4, 6);
                    }
                } else if (i % 2 === 0 && h > 40) {
                    ctx.fillRect(drawX + 8, GROUND_Y - h + 10, 8, 8);
                }
                ctx.fillStyle = "#1a0b1c";
            }

            // Draw Clouds (Parallax)
            ctx.fillStyle = COLORS.cloud;
            for (let i = clouds.length - 1; i >= 0; i--) {
                let c = clouds[i];
                c.x -= c.speed;
                ctx.fillRect(c.x, c.y, c.w, c.h);
                ctx.fillRect(c.x + 8, c.y - 8, c.w - 16, 8);
                if (c.x + c.w < 0) clouds.splice(i, 1);
            }

            // Draw Ground
            groundOffset = (groundOffset + currentSpeed) % CANVAS_WIDTH;
            ctx.fillStyle = COLORS.ground;
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

            // Ground Texture (Scrolling pixels)
            ctx.fillStyle = COLORS.groundDark;
            for (let i = 0; i < CANVAS_WIDTH; i += 20) {
                let gx = (i - Math.floor(groundOffset)) % CANVAS_WIDTH;
                if (gx < 0) gx += CANVAS_WIDTH;
                ctx.fillRect(gx, GROUND_Y + 4, 4, 2);
                ctx.fillRect((gx + 10) % CANVAS_WIDTH, GROUND_Y + 12, 6, 2);
            }

            // Draw Dino
            dino.draw();

            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                p.x += p.dx;

                // Draw (Square)
                drawSprite(ctx, Sprites.projectile, p.x, p.y, 2, COLORS.projectile);

                if (p.x > CANVAS_WIDTH) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Check Collision
                let hit = false;
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    let ob = obstacles[j];
                    if (
                        p.x < ob.x + ob.w &&
                        p.x + p.w > ob.x &&
                        p.y < ob.y &&
                        p.y + p.h > ob.y - ob.h
                    ) {
                        obstacles.splice(j, 1);
                        hit = true;
                        spawnDust(ob.x + ob.w / 2, ob.y - ob.h / 2);
                        AudioSys.collect();
                        comboCount++;
                        // Bonus points for kill
                        let killScore = 10 * (1 + Math.floor(comboCount / 5));
                        if (ob.type === 'bird') {
                            killScore += 20; // Bonus for bird
                            // Floating Text
                            particles.push({
                                x: ob.x,
                                y: ob.y - 20,
                                dx: 0,
                                dy: -1,
                                life: 40,
                                text: "+20",
                                color: "#ffff00"
                            });
                        }
                        score += killScore;
                        break;
                    }
                }
                if (hit) projectiles.splice(i, 1);
            }

            // Gems
            for (let i = gems.length - 1; i >= 0; i--) {
                let g = gems[i];
                g.x -= currentSpeed;
                let by = g.y + Math.sin(frames * 0.1) * 5;
                drawSprite(ctx, Sprites.gem, g.x, by - 14, 2, COLORS.gem);

                // Gem uses Top-Left coords for y since we drew at by-14?
                // Wait, drawSprite(x, y) draws at x,y.
                // We passed g.x, by-14. So Top is by-14. Height 14.
                // So Rect is {x: g.x, y: by-14, w: 14, h: 14, isTopLeft: true}

                let gemRect = { x: g.x, y: by - 14 + 14, w: 14, h: 14 }; // Passing y as "Bottom" to match checkCollision default
                let dinoRect = { x: dino.x, y: dino.y, w: dino.w, h: dino.h };

                if (checkCollision(dinoRect, gemRect)) {
                    score += g.value;
                    AudioSys.collect();
                    gems.splice(i, 1);
                    continue;
                }
                if (g.x + 20 < 0) gems.splice(i, 1);
            }

            // Powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                let p = powerups[i];
                p.x -= currentSpeed;
                let by = p.y + Math.sin(frames * 0.1) * 5;
                let sprite = p.type === 'shield' ? Sprites.shield : Sprites.double;
                let col = p.type === 'shield' ? COLORS.shield : COLORS.double;

                drawSprite(ctx, sprite, p.x, by - 14, 2, col);

                let pRect = { x: p.x, y: by - 14 + 14, w: 14, h: 14 }; // y as Bottom
                let dinoRect = { x: dino.x, y: dino.y, w: dino.w, h: dino.h };

                if (checkCollision(dinoRect, pRect)) {
                    AudioSys.powerup();
                    if (p.type === 'shield') dino.shieldTime = 600;
                    if (p.type === 'double') dino.doubleScoreTime = 600;
                    powerups.splice(i, 1);
                    continue;
                }
                if (p.x + 20 < 0) powerups.splice(i, 1);
            }

            // Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                ob.x -= currentSpeed;

                let spriteToDraw = ob.sprite;
                if (ob.type === 'bird') {
                    spriteToDraw = (Math.floor(frames / 15) % 2 === 0) ? Sprites.bird1 : Sprites.bird2;
                    // Glitch Bird Variant (Random Y fluctuation)
                    if (ob.isGlitch) {
                        ob.y += Math.sin(frames * 0.2) * 2;
                        // Color flicker handled in draw? No, we need to pass color.
                    }
                }

                let color = ob.type === 'bird' ? COLORS.bird : COLORS.cactus;
                if (ob.isGlitch) color = (Math.floor(frames / 4) % 2 === 0) ? "#ff00ff" : "#00ffff";

                drawSprite(ctx, spriteToDraw, ob.x, ob.y - ob.h, ob.scale, color);

                let dinoRect = { x: dino.x, y: dino.y, w: dino.w, h: dino.h };
                let obRect = { x: ob.x, y: ob.y, w: ob.w, h: ob.h };

                if (checkCollision(dinoRect, obRect)) {
                    if (!cheatMode && dino.shieldTime <= 0) {
                        isPlaying = false;
                        AudioSys.die();
                        if (navigator.vibrate) navigator.vibrate(300);
                        screenShake = 10;

                        // Save High Score
                        if (score > highScore) {
                            highScore = score;
                            document.getElementById('high-score-display').innerText = highScore.toString().padStart(5, '0');
                            try { localStorage.setItem('dinoHighScore', highScore); } catch (e) { }
                        }

                        document.getElementById('final-score').innerText = "SCORE: " + score;
                        document.getElementById('game-over-screen').classList.remove('hidden');
                        return;
                    } else if (dino.shieldTime > 0) {
                        dino.shieldTime = 0;
                        obstacles.splice(i, 1);
                        spawnDust(ob.x, ob.y - ob.h / 2);
                        AudioSys.jump();
                    }
                }

                if (ob.x + ob.w < 0) {
                    obstacles.splice(i, 1);
                }
            }

            // Draw Boss
            if (isBossActive) {
                // Draw Boss
                drawSprite(ctx, Sprites.boss, boss.x, boss.y, 4, "#ff0000"); // Red Boss
                // HP Bar
                ctx.fillStyle = "#550000";
                ctx.fillRect(boss.x, boss.y - 10, 40, 4);
                ctx.fillStyle = "#ff0000";
                ctx.fillRect(boss.x, boss.y - 10, 40 * (boss.hp / boss.maxHp), 4);

                // Draw Boss Proj
                for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                    let bp = bossProjectiles[i];
                    bp.x += bp.dx;
                    ctx.fillStyle = "#ff0000";
                    ctx.fillRect(bp.x, bp.y, bp.w, bp.h);

                    if (bp.x < 0) bossProjectiles.splice(i, 1);

                    // Hit Player?
                    let pRect = { x: bp.x, y: bp.y + bp.h, w: bp.w, h: bp.h }; // y as bottom
                    let dinoRect = { x: dino.x, y: dino.y, w: dino.w, h: dino.h };
                    if (checkCollision(dinoRect, pRect)) {
                        if (!cheatMode && dino.shieldTime <= 0) {
                            // Copied death logic
                            isPlaying = false;
                            AudioSys.die();
                            if (navigator.vibrate) navigator.vibrate(300);
                            screenShake = 10;
                            // Save High Score
                            if (score > highScore) {
                                highScore = score;
                                document.getElementById('high-score-display').innerText = highScore.toString().padStart(5, '0');
                                try { localStorage.setItem('dinoHighScore', highScore); } catch (e) { }
                            }
                            document.getElementById('final-score').innerText = "SCORE: " + score;
                            document.getElementById('game-over-screen').classList.remove('hidden');
                            return;
                        } else if (dino.shieldTime > 0) {
                            bossProjectiles.splice(i, 1);
                            dino.shieldTime = 0;
                        }
                    }
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.dx;
                p.y += p.dy;
                p.life--;

                ctx.fillStyle = p.color || "#ffffff";

                if (p.text) {
                    // Draw Floating Text
                    if (p.isGrand) {
                        ctx.font = "20px 'Press Start 2P'";
                        ctx.fillStyle = p.color;
                        ctx.fillText(p.text, p.x, p.y);
                    } else {
                        ctx.font = "10px 'Press Start 2P'";
                        ctx.fillStyle = p.color;
                        ctx.fillText(p.text, p.x, p.y);
                    }
                } else {
                    // Draw Square Particle
                    if (p.life > 0) ctx.fillRect(p.x, p.y, 2, 2);
                }

                if (p.life <= 0) particles.splice(i, 1);
            }

            ctx.restore(); // Restore Shake
        }

        /**
         * INPUT HANDLING
         */
        function handleInput(e) {
            if (!isPlaying) {
                const gameOverVis = !document.getElementById('game-over-screen').classList.contains('hidden');
                const startVis = !document.getElementById('start-screen').classList.contains('hidden');

                if (startVis || gameOverVis) {
                    resetGame();
                }
            }
            // Even if playing, handle these:

            if (!isPlaying) return;

            if (e.code === 'Space' || e.code === 'ArrowUp') {
                dino.jump();
                e.preventDefault();
            }
            if (e.code === 'ArrowDown') {
                dino.isDucking = true;
                e.preventDefault();
            }
            if (e.code === 'KeyF' || e.code === 'KeyZ') {
                dino.shoot();
            }
            if (e.code === 'KeyP' || e.code === 'Escape') {
                togglePause();
            }
            if (e.code === 'KeyC') {
                cheatMode = !cheatMode;
            }
            if (e.key >= '1' && e.key <= '4') {
                let idx = parseInt(e.key) - 1;
                // Skin Unlocks: 0 (Green) always, 1 (Cyan) > 1000, 2 (Pink) > 2500, 3 (White) > 5000
                let required = [0, 1000, 2500, 5000];
                if (highScore >= required[idx]) {
                    dino.skinIdx = idx;
                    if (navigator.vibrate) navigator.vibrate(50);
                } else {
                    // Locked feedback?
                    if (navigator.vibrate) navigator.vibrate([50, 50, 50]); // Error buzz
                }
            }
        }

        window.addEventListener('keydown', handleInput);

        window.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowDown') dino.isDucking = false;
        });

        function togglePause() {
            if (!isPlaying) return;
            isPaused = !isPaused;
            // Draw Pause Overlay if paused
            if (isPaused) {
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = "#fff";
                ctx.font = "16px 'Press Start 2P'";
                ctx.fillText("SIGNAL LOST", CANVAS_WIDTH / 2 - 60, CANVAS_HEIGHT / 2);
            } else {
                loop();
            }
        }

        const wrapper = document.getElementById('game-wrapper');
        // Swipe Detection variables
        let touchStartY = 0;

        const touchHandler = (e) => {
            if (e.type === 'touchstart') {
                touchStartY = e.touches[0].clientY;
            }

            if (e.type === 'touchend') {
                // Check swipe
                let touchEndY = e.changedTouches[0].clientY;
                if (touchEndY - touchStartY > 30) {
                    // Swipe Down
                    dino.isDucking = true;
                    setTimeout(() => dino.isDucking = false, 500); // Auto-stand after 500ms on mobile
                    return;
                }
            }

            if (!isPlaying) {
                resetGame();
            } else {
                if (e.type !== 'touchend') {
                    // Get click/touch position relative to the element
                    const rect = wrapper.getBoundingClientRect();
                    let clientX = e.clientX;

                    // If it's a touch event, it might have multiple touches, take the first changed one
                    if (e.changedTouches && e.changedTouches.length > 0) {
                        clientX = e.changedTouches[0].clientX;
                    }

                    const x = clientX - rect.left;

                    // Split screen controls: Left half Shoot, Right half Jump
                    if (x < rect.width / 2) {
                        dino.shoot();
                    } else {
                        dino.jump();
                    }
                }
            }
            if (e.cancelable) e.preventDefault();
        };
        wrapper.addEventListener('mousedown', touchHandler);
        wrapper.addEventListener('touchstart', touchHandler, { passive: false });
        wrapper.addEventListener('touchend', touchHandler, { passive: false });

        // Initial render call to show background before start
        ctx.fillStyle = COLORS.sky;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.fillStyle = COLORS.ground;
        ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
        spawnCloud();

    </script>
</body>

</html>
